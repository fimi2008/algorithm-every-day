# 1-认识复杂度、对数器、二分法与异或运算
## 何为常数时间的操作?
> 如果一个操作的执行时间不以具体样本量为转移，每次执行时间都是固定时间。称这样的操作为常数时间的操作。

## 常见的常数时间的操作
* 常见的算法运算(+、-、*、%等)
* 常见的位运算(>>,>>>,<<,|,&,^)
* 赋值,比较,自增,自减操作等
* 数组寻址操作
> 总之,执行时间固定的操作都是常数时间的操作.<br>
> 反之,执行时间不固定的操作,都不是常数时间的操作.<br>
> Array是常数实现操作
 
## 如何确定算法流程的总操作数量与样本数量之间的表达式关系?
1.想象该算法流程所处理的数据状况,要按照最差情况来.
2.把整个流程彻底拆分为一个个基本动作,保证每个动作都是常数时间的操作.
3.如果数量为N,看看基本动作的数量和N是什么关系.

## 如何确定算法流程的时间复杂度?
> 当完成了表达式的建立，只要把最高阶项留下即可。低阶项都去掉,高阶项的系数也去掉。<br>
> 记为: 0(忽略掉系数的高阶项)

## 时间复杂度的意义
> 抹掉了好多东西，只剩下了一个最高阶项啊..<br>
> 那这个东西有什么意义呢?<br>
> 时间复杂度的意义在于:<br>
> 当我们要处理的样本量很大很大时，我们会发现低阶项是什么不是最重要的;每-项的系数是什么，不是最重要的。真正重要的就是最高阶项是什么。<br>
> 这就是时间复杂度的意义，它是衡量算法流程的复杂程度的一种指标，该指标只与数据量有关，与过程之外的优化无关。

## 通过三个具体的例子，来实践一把时间复杂度的估算
* 选择排序: [例子](https://github.com/fimi2008/algorithm-every-day/tree/master/src/main/java/top/lionxxw/learn/algorithm/lesson/day01/SelectionSort.java)
* 冒泡排序: [例子](https://github.com/fimi2008/algorithm-every-day/tree/master/src/main/java/top/lionxxw/learn/algorithm/lesson/day01/BubbleSort.java)
* 插入排序: [例子](https://github.com/fimi2008/algorithm-every-day/tree/master/src/main/java/top/lionxxw/learn/algorithm/lesson/day01/InsertionSort.java)

## 如何确定算法流程的总操作数量与样本数量之间的表达式关系?
1.想象该算法流程所处理的数据状况，要按照最差情况来。
2.把整个流程彻底拆分为一个个基本动作，保证每个动作都是常数时间的操作。
3.如果数据量为N，看看基本动作的数量和N是什么关系。

## 常见的时间复杂度
> O(1) > O(logN) > O(N) > O(N*logN) > O(N^k) > O(k^N) > O(N!)   

## 认识对数器
1. 你想要测的方法a
2. 实现复杂度不好,但是结果正确的方法b
3. 随机生成不同的样本数据,进行方法a,b进行对比测试结果是否正确

## 评估算法优劣的核心指标是什么? 
* 时间复杂度(流程决定)
* 额外空间复杂度(流程决定)
* 常数项时间(实现细节决定)

## 额外空间复杂度
> 你要实现一个算法流程，在实现算法流程的过程中，你需要开辟一些空间来支持你的算法流程。
作为输入参数的空间，不算额外空间。
作为输出结果的空间，也不算额外空间。
因为这些都是必要的、和现实目标有关的。所以都不算。
但除此之外，你的流程如果还需要开辟空间才能让你的流程继续下去。这部分空间就是额外空间。
如果你的流程只需要开辟有限几个变量，额外空间复杂度就是0(1)。